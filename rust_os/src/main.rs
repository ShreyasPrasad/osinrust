// in src/main.rs

#![no_std]
#![no_main]
#![feature(custom_test_frameworks)]
#![test_runner(rust_os::test_runner)]
#![reexport_test_harness_main = "test_main"]

use core::panic::PanicInfo;
use rust_os::println;

/* There's a lot of different types of CPU exceptions, such as those caused by accessing a write-only
page, or dividing by 0, or accessing a privileged instruction in user mode. 

When an exception occurs, the CPU invokes the corresponding handler function. If an error invokes there
too, a double fault exception is raised and the double fault handler is invoked. If that also errors,
the operating system reboots. 

To handle exceptions, we setup the interrupt descriptor table (IDT). The hardware uses this table directly.
Each row has the same 16-byte format, consisting of the pointer to the handler function and some extra options. 

Each exception has a predefined IDT index. Thus the hardware can automatically load the the IDT entry for each
exception. When an exception occurs*/

#[no_mangle]
pub extern "C" fn _start() -> ! {
    println!("Hello World{}", "!");

    rust_os::init();

    // invoke a breakpoint exception
    x86_64::instructions::interrupts::int3(); // new

    /* Use conditional compilation to add the call to test_main only in test contexts because 
    the function is not generated on a normal run. */
    #[cfg(test)]
    /* test_main is generated by the test framework and it just invokves the test_runner. */
    test_main();

    loop {}
}

/// This function is called on panic.
#[cfg(not(test))]
#[panic_handler]
fn panic(info: &PanicInfo) -> ! {
    println!("{}", info);
    loop {}
}

#[cfg(test)]
#[panic_handler]
fn panic(info: &PanicInfo) -> ! {
    rust_os::test_panic_handler(info)
}
